package cicd

import (
	"git.stuhome.com/Sunmxt/wing/common"
	ccommon "git.stuhome.com/Sunmxt/wing/controller/common"
	"git.stuhome.com/Sunmxt/wing/model/sae"
	"git.stuhome.com/Sunmxt/wing/model/scm"
	"git.stuhome.com/Sunmxt/wing/model/scm/gitlab"

	"github.com/jinzhu/gorm"

	"io"
	"net/url"
	"strconv"
	"strings"
)

func GenerateGitlabCIJobsForRepository(ctx *ccommon.OperationContext, repositoryID uint) (map[string]*gitlab.CIJob, error) {
	db, err := ctx.Database()
	if err != nil {
		return nil, err
	}
	var externalURL *url.URL
	if externalURL, err = url.Parse(ctx.Runtime.Config.ExternalURL); err != nil {
		ctx.Log.Error("invalid external url: " + ctx.Runtime.Config.ExternalURL)
		return nil, err
	}
	var builds []scm.CIRepositoryBuild
	if err = db.Where("repository_id = (?) and exec_type = (?) and active = (?)", repositoryID, scm.GitlabCIBuild, scm.Active).Find(&builds).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			return nil, nil
		}
		return nil, err
	}
	jobs := map[string]*gitlab.CIJob{}
	buildIDSet := common.NewIntSet()
	for _, build := range builds {
		buildIDSet.Add(build.Basic.ID)

		token := common.GenerateRandomToken()
		name := "wing-dynamic-build-" + token
		externalURL.Path = "api/scm/builds/" + strconv.FormatInt(int64(build.Basic.ID), 10) + "/job"
		jobURL := externalURL.String()
		externalURL.Path = "api/scm/builds/" + strconv.FormatInt(int64(build.Basic.ID), 10) + "/result/report"
		reportURL := externalURL.String()
		job := &gitlab.CIJob{
			Stage: "build",
			Script: []string{
				"ci_build wing-gitlab '" + build.ProductPath + "'",
			},
			Only: []string{strings.Replace(build.Branch, " ", "", -1)},
			Variables: map[string]interface{}{
				"WING_PRODUCT_TOKEN": token,
				"WING_REPORT_URL":    reportURL,
				"WING_JOB_URL":       jobURL,
			},
		}
		jobs[name] = job
	}
	var (
		cluster []sae.ApplicationCluster
		depends []sae.BuildDependency
	)
	if err = db.Where("build_id in (?)", buildIDSet.List()).Model(sae.BuildDependency{}).Find(&depends).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			return jobs, nil
		}
		return nil, err
	}
	appIDSet := common.NewIntSet()
	for _, depend := range depends {
		appIDSet.Add(depend.ApplicationID)
	}
	appIDSet.Visit(func(appID int) bool {
		cluster = cluster[0:0]
		if err = db.Where("application_id = (?)", appID).
			Model(sae.ApplicationCluster{}).
			Select("id").Find(&cluster).Error; err != nil {
			if gorm.IsRecordNotFoundError(err) {
				return true
			}
			return false
		}
		for _, c := range cluster {
			externalURL.Path = "api/scm/builds/runtime/" + strconv.FormatInt(int64(c.Basic.ID), 10) + "/job"
			jobURL := externalURL.String()
			externalURL.Path = "api/scm/builds/runtime/" + strconv.FormatInt(int64(c.Basic.ID), 10) + "/result/report"
			reportURL := externalURL.String()
			job := &gitlab.CIJob{
				Stage: "integrate",
				Script: []string{
					"build_runtime_image wing-gitlab",
				},
				Variables: map[string]interface{}{
					"WING_JOB_URL":       jobURL,
					"WING_REPORT_URL":    reportURL,
					"WING_PRODUCT_TOKEN": common.GenerateRandomToken(),
				},
			}
			jobName := "wing-dynamic-runtime-build-" + strconv.FormatInt(int64(c.Basic.ID), 10)
			jobs[jobName] = job
		}
		return true
	})
	if err != nil {
		return nil, err
	}
	return jobs, nil
}

func GenerateScriptForBuild(ctx *ccommon.OperationContext, w io.Writer, build *scm.CIRepositoryBuild) error {
	io.WriteString(w, "#! /usr/bin/env bash \n")
	io.WriteString(w, "# Generated by Wing. \n\n")
	io.WriteString(w, build.BuildCommand)
	return nil
}

func GenerateScriptForGitlabCIRuntimeBuild(ctx *ccommon.OperationContext, w io.Writer, deployment *sae.ApplicationDeployment) error {
	if _, err := io.WriteString(w, "#! /usr/bin/env bash \n"); err != nil {
		return err
	}
	if _, err := io.WriteString(w, "# Generated by Starstudio App Engine. \n\n"); err != nil {
		return err
	}
	specDetail := &sae.ClusterSpecificationDetail{}
	if err := deployment.NewSpecification.GetSpecification(specDetail); err != nil {
		return err
	}
	if _, err := io.WriteString(w, "runtime_image_base_image '"+specDetail.BaseImage+"' \n"); err != nil {
		return err
	}
	if specDetail.Command != "" {
		// 服务名需要规范化，这里先不管
		if _, err := io.WriteString(w, "runtime_image_add_service normal '"+
			deployment.Cluster.Application.ServiceName+"' "+
			specDetail.Command+"\n"); err != nil {
			return err
		}
	}
	for _, ref := range specDetail.Product {
		depCmd := "runtime_image_add_dependency "
		if ref.Namespace != "" {
			depCmd = depCmd + "-r '" + ref.Namespace + "' "
		}
		if ref.Environment != "" {
			depCmd = depCmd + "-e '" + ref.Environment + "' "
		}
		if ref.Tag != "" {
			depCmd = depCmd + "-t '" + ref.Tag + "'"
		}
		depCmd = depCmd + "\n"
		if _, err := io.WriteString(w, depCmd); err != nil {
			return err
		}
	}
	if _, err := io.WriteString(w, "build_runtime_image wing-gitlab -e CI_COMMIT_REF_NAME\n"); err != nil {
		return err
	}
	return nil
}
